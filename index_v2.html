<!DOCTYPE>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="css_v2.css">
	<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7/jquery.min.js"></script>-->
	<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.2.1/underscore-min.js"></script>-->
	<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.5.3/backbone-min.js"></script>-->
</head>
<body>

	<div id="calendarLayer"></div>
	<div class="calendarLayer"></div>
	<script type="text/javascript" src="index_v2.js"></script>
	<script type="text/javascript">
	'use strict';

//		Function.prototype.bind = function (thisArg) {
//			var self = this,
//				slice = Array.prototype.slice,
//				args = slice.call(arguments , 1);
////				console.log(thisArg);
////				console.log(args.concat(slice.call(arguments)));
////			var arr = args.concat(slice.call(arguments));
////			console.log(arr);
//			return function () {
////				return self.apply(thisArg, args);
//				return self.apply(thisArg, args.concat(slice.call(arguments)));
////				return self.apply(thisArg, ['ddd', 'aaa', '3311113',two, 'ddd', 'aaa', '3311113']);
//			};
//		};

//var myfunc = function(arg1, arg2){
//	console.log(this);
//	console.log(arg1);
//	console.log(arg2);
//};
//var bindedMyfunc = Function.prototype.bind.apply(myfunc, ["mythis", "param1", "param2"]);
//bindedMyfunc();


/**
 * function bind, call, apply, concat test...
 */

//		var Book = Backbone.Model.extend({
//			defaults: {
//				sort: 'default',
//				title: 'default Title'
//			}
//		});
//
//		var book1 = new Book({sort: 'JavaScript', title: 'JavaScript Book 1'}),
//				book2 = new Book({sort: 'JavaScript', title: 'JavaScript Book 2'}),
//				book3 = new Book({sort: 'JavaScript', title: 'JavaScript Book 3'});
//
//		var Books = Backbone.Collection.extend({		// Books 라는 collection을 만듭니다.
//			model: Book
//		});
//
//		var books = new Books();	// books 라는 Books collection의 인스턴스를 만듭니다.
//
//		books.add([book1, book2, book3]);	// add 메서드를 사용해서 model들을 books에 넣습니다.
//		console.log(books);
//
//
//function callMe(arg1) {
//	console.log(this);
//	console.log(arg1);
////	var s = " ";
////	s += "this value : " + this;
////	s += "<br />";
////	for (var i in callMe.arguments) {
////		s+= "arguments : " + callMe.arguments[i];
////	}
////	return s;
//}
////document.write("Original function: <br/>");
////document.write(callMe(1, 2));
////
//
//
////document.write("<br/>");
////document.write("Function called with call: <br/>");
//document.write(callMe.call({aa:'aa'}, 4, 5));
//

		(new sui.component.createCalendar({
			elementId : 'calendarLayer'
		}));



//call, apply, bind 활용의 예
//
/**
Function.prototype.bind = function (thisArg) {
	var self = this,
		slice = Array.prototype.slice,
		args = slice.call(arguments , 1);
//		console.log(this);
//		console.log(thisArg);

	return function () {
		return self.apply(thisArg, args.concat(slice.call(arguments)));
	};
};
*/

var one = {
	name : "object",
	say: function (greet) {
		return greet + ", " + this.name;
	}
};

var two = {
	name : "author object"
};

//step 1, apply - array[]
var apply = one.say.apply(two, ['apply', 'apply2']);
//console.log(apply);

//step 2, call - parameter, parameter....
//var call = one.say.call(two, 'call');
//console.log(call);

//step 3, bind
//var bind1 = one.say.bind(two);
//console.log(bind1('function bind1'));
//console.log(bind1('function bind1', 'function bind2', 'function bind3'));

//var bind2 = one.say.bind(two, 'function bind2');
//console.log(bind2());

//step 4, 응용
var myfunc = function(arg1, arg2, array1){
	console.log(arg1, arg2, array1, this.name);
//	console.log(this);
//	alert("this = " + this + ", arg1 = " + arg1 + ", arg2 = " + arg2);
};
//var bindedMyfunc = Function.prototype.bind.apply(myfunc, ["mythis", "param1", "param2"]);
//bindedMyfunc();

var obj = {
	name : 'sihyun'
};

var instance = myfunc.call(obj, 'arg1', 'arg2', ['111', '222', '333']);
console.log(instance);
/**
 * 다음 함수들은 함수를 간접적으로 호출하면서 this의 객체를 변경할 수 있다.
 * call, apply, bind
 * call : 호출 메서드의 call에 this를 적용 시킬 대상객체와 호출 메서드의 필요 인자를 넘길경우 결과값 반환.
 * apply : 호출 메서드의 apply에 this를 적용 시킬 대상객체와 호출 메서드의 필요 배열을 넘길경우 결과값 반환.
 * bind : call과 다소 유사한 모습을 보이며 호출 메서드의 bind할 해당 this를 적용 시킬 대상객체와 호출 메서드의 parameter or 배열을 넘기면서 새로운 함수를 함수 반환.
 * 결론  : call, apply, bind 모두 유사한 기능을 지니고 있으며, 사용자 임의로 this의 객체(context의 유효범위)를 마음껏 변경 할 수 있다. 각각의 인자로 넘길때 각각의 개별인지, 배열인지 혹은 결과가 값인지 함수인지의 차이인것이다.
 */


var Closure = function ( ) {


	var name = 'Yoobin',
		age = 26;

	return function() {
		return name + ", " + age;
	}
};

var closure = Closure();

//console.log(closure());





</script>

</body>

</html>