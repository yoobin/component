<!DOCTYPE>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="css_v2.css">
	<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7/jquery.min.js"></script>-->
	<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.2.1/underscore-min.js"></script>-->
	<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.5.3/backbone-min.js"></script>-->
</head>
<body>

	<div id="calendarLayer"></div>
	<div class="calendarLayer"></div>
	<script type="text/javascript" src="index_v2.js"></script>
	<script type="text/javascript">
	'use strict';

//		Function.prototype.bind = function (thisArg) {
//			var self = this,
//				slice = Array.prototype.slice,
//				args = slice.call(arguments , 1);
////				console.log(thisArg);
////				console.log(args.concat(slice.call(arguments)));
////			var arr = args.concat(slice.call(arguments));
////			console.log(arr);
//			return function () {
////				return self.apply(thisArg, args);
//				return self.apply(thisArg, args.concat(slice.call(arguments)));
////				return self.apply(thisArg, ['ddd', 'aaa', '3311113',two, 'ddd', 'aaa', '3311113']);
//			};
//		};

//var myfunc = function(arg1, arg2){
//	console.log(this);
//	console.log(arg1);
//	console.log(arg2);
//};
//var bindedMyfunc = Function.prototype.bind.apply(myfunc, ["mythis", "param1", "param2"]);
//bindedMyfunc();


/**
 * function bind, call, apply, concat test...
 */

//		var Book = Backbone.Model.extend({
//			defaults: {
//				sort: 'default',
//				title: 'default Title'
//			}
//		});
//
//		var book1 = new Book({sort: 'JavaScript', title: 'JavaScript Book 1'}),
//				book2 = new Book({sort: 'JavaScript', title: 'JavaScript Book 2'}),
//				book3 = new Book({sort: 'JavaScript', title: 'JavaScript Book 3'});
//
//		var Books = Backbone.Collection.extend({		// Books 라는 collection을 만듭니다.
//			model: Book
//		});
//
//		var books = new Books();	// books 라는 Books collection의 인스턴스를 만듭니다.
//
//		books.add([book1, book2, book3]);	// add 메서드를 사용해서 model들을 books에 넣습니다.
//		console.log(books);
//
//
//function callMe(arg1) {
//	console.log(this);
//	console.log(arg1);
////	var s = " ";
////	s += "this value : " + this;
////	s += "<br />";
////	for (var i in callMe.arguments) {
////		s+= "arguments : " + callMe.arguments[i];
////	}
////	return s;
//}
////document.write("Original function: <br/>");
////document.write(callMe(1, 2));
////
//
//
////document.write("<br/>");
////document.write("Function called with call: <br/>");
//document.write(callMe.call({aa:'aa'}, 4, 5));
//

		(new sui.component.createCalendar({
			elementId : 'calendarLayer'
		}));



//call, apply, bind 활용의 예
//
Function.prototype.bind = function (thisArg) {
	var self = this,
		slice = Array.prototype.slice,
		args = slice.call(arguments , 1);
//		console.log(this);
//		console.log(thisArg);

	return function () {
		return self.apply(thisArg, args.concat(slice.call(arguments)));
	};
};


var one = {
	name : "object",
	say: function (greet) {
		return greet + ", " + this.name;
	}
};

var two = {
	name : "author object"
};

//step 1, apply - array[]
var apply = one.say.apply(two, ['apply', 'apply2']);
console.log(apply);

//step 2, call - parameter, parameter....
//var call = one.say.call(two, 'call');
//console.log(call);

//step 3, bind
//var bind1 = one.say.bind(two);
//console.log(bind1('function bind1'));
//console.log(bind1('function bind1', 'function bind2', 'function bind3'));

//var bind2 = one.say.bind(two, 'function bind2');
//console.log(bind2());

//step 4, 응용
var myfunc = function(arg1, arg2){
//	console.log(this);
	alert("this = " + this + ", arg1 = " + arg1 + ", arg2 = " + arg2);
};
var bindedMyfunc = Function.prototype.bind.apply(myfunc, ["mythis", "param1", "param2"]);
//bindedMyfunc();

/**
 * call, apply, bind 각각의 차이는
 * call : 호출 메서드의 call에 대상객체와 parameter1, parameter2, ... 을 각각의 parameter 로 넘겨주면서 해당 객체의 유효범위를 대상객체로 지정할 수 있다. 결과값 반환
 * apply : 호출 메서드의 apply에 대상객체와 배열을 넘기면서 해당 객체의 유효범위를 대상객체로 교체한다. 결과값 반환
 * bind : 호출 메서드의 bind에 해당 대상객체와 parameter or 배열을 넘기면서 해당 객체의 유효범위를 대상객체로 지정할 수 있다. 함수 반환
 *
 * 결론 : call의 파라메터로 결과값을 받는가, apply의 배열로 결과값을 받는가, bind의 파라메터 or 배열로 함수를 받는가의 차이인것이며, 대상객체로 context의 유효범위를 지정할 수 있다.
 */


var Closure = function ( ) {


	var name = 'Yoobin',
		age = 26;

	return function() {
		return name + ", " + age;
	}
};

var closure = Closure();

//console.log(closure());





</script>

</body>

</html>